# -*- coding: utf-8 -*-
"""Taller#1_Kevin Olivera.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oMi34pr88MLV0jjumocJrK94byg1zQXL

![UNIVERSIDAD_ECCI.png](data:image/png;base64,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)

#Laboratori #1️⃣
##**Nombre:** Kevin Steven Olivera Caicedo
##**Codigo:** 64178
###**Grupo:** #2
"""

from google.colab import drive
drive.mount('/content/drive')

"""Lo primero que vamos hacer es importar las herramietas necesarias, ademas le damos el nombre de "PD" a la libreria de pandas. Además esta libretia "matplotlib.pylot" no ayuda a generar graficos en 2D."""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

"""Esta es la estructura de un DataFrame, lo cual es basicamente una estructura de datos con filas y columnas. En la libreria Pandas las comlumnas se llaman serries."""

data = {'year': [
       2010, 2011, 2012,
       2010, 2011, 2012,
       2010, 2011, 2012
    ],
    'team':[
        'FCBarcerlona', 'FCBarcelona',
        'FCBarcelona', 'RMadrid',
        'RMadrid', 'RMadrid',
        'ValenciaCF', 'ValenciaCF',
        'ValenciaCF'
    ],
    'wins': [30, 28, 32, 29, 32, 26, 21, 17, 19],
    'draws': [6, 7, 4, 5, 4, 7, 8, 10, 8],
    'losses': [2, 3, 2, 4, 2, 5, 9, 11, 11]
        }
football = pd.DataFrame(data, columns = [
    'year', 'team', 'wins', 'draws', 'losses'
    ]
)
print(football)

"""Ahora leeremos y mostraremos el contenido de un archivo .CSV, para eso usaremos la funcion 'read' ademas esta funcion puede leer una diversa cantidad de archivos."""

edu = pd.read_csv('/content/educ_figdp_1_Data.csv',
                  na_values = ':',
                  usecols = ['TIME', 'GEO', 'Value'])
edu

"""'head' nos trae solo las 5 primeras filas por default, pero si se quiere mostrar otro numero diferente a 5 se le puede poner en el contexto el numero de filas las cuales quieres que muestre."""

edu.head(9)

"""'Tail' realiza la misma funcion que 'head' pero de abajo hacia arriba."""

edu.tail(9)

"""Con la funcion 'describe' podemos obtener la desviacion estandar, el minimo y maximo, el recuento, ademas de los porsentajes por defectos los cuales son 25, 50 y 70, para todos los valores de cada columna"""

edu.describe()

"""Tambien se puden seleccionar sub-conjuntos de datos de la tabla, de la siguiente manera."""

edu['Value']

edu['GEO']

"""
Para indicar un sub-conjunto de filas podemos poner los parametros de la siguiente manera [desde donde comienza:hasta donde termina]"""

edu[10:20]

"""'loc' devuelve un elemento que se encuentra en una fila, con nombre de la fila ula columna.
En este caso traemos las filas TIME y GEO, desde la posición 90 a la posición 94.
'ix' se usaba para lo mismo, pero en la versión de python 2.
"""

edu.loc[90:98, ['TIME', 'GEO']]

"""Otra forma de seleccionar un sub-conjunto, es por medio de una indexación booleana, lo que comunmente se conoce como un filtro. En ejemplo vemos como filtrar los valores menores o iguales a 6.5, de abajo hacia arriba."""

edu[edu['Value'] >= 6.5].tail(16)

"""En este caso, se traeran todos los valores que sean null, o que sean false, esto con la función 'isnull'. Al adicionarle la fucnion 'head; se traeran los datos de arriba hacia abajo."""

edu[edu['Value'].isnull()].head(13)

"""'axis = 0' el arreglo se recorre por las columnas.
'axis = 1' el arreglo se recorre por las filas.
mientras que la funcion 'max' trae el número mas grandre en este caso de la columna.

"""

edu.max(axis = 0)

"""Esta es una diferencia en las funciones genericas de Pandas y de Python, ya que la funcion max en python, devulve NaN, ya que por la interpretacion matematica este seria el maximo, mientras que en Pandas, los valores con NaN se toman como valores perdidos, por lo que trae solo los numeros maximos."""

print ('Pandas max function:', edu['Value'].max())
print ('Python max function:', max(edu['Value']))

"""Se le aplicara una división a toda la fila de Value, esto se puede hacer con las demas operaciones aritmeticas. Claro que para acortar los resultado, usaremos 'head'."""

s = edu['Value']/100
s.head(10)

"""'sqrt' es una funcion usada para sacar la raiz cuadrada a un valor.
'apply' en este caso se usa para aplicar la funcion 'sqrt' a cada elemeplo de la fila o columna.
"""

s = edu['Value'].apply(np.sqrt)
s.head(12)

"""
Al momento de hacer una funcion especifica, podemos escribir una función en liena, comúnmente conocida como lambda, con lo cual solo es necesario especificar los parametros que se van a recibir, entre la palabra lambda y los dos puntos. 'C'solo es una variable en donde guardamos los datos de la tabla Value para poder hacer la operación."""

s = edu['Value'].apply(lambda c: c**2)
s.head()

"""Se crea la columna 'ValueNorm', para esto se usa el signo '='. Los datos de esta colmna se llenan con los valores resultantes de la operación de dividir la columna 'Value' por el valor maximo de la misma colunma."""

edu['ValueNorm'] = edu['Value']/edu['Value'].max()
edu.tail(13)

"""Si se desea eliminar las columna(axis = 1) creada o la fila(axis = 0) creada se usa la función 'drop'. Pero esta función 'drop' por defecto devuelve una copia de los datos modificados, en vez de sobrescribir el DataFrame, con lo que se mantiene el DataFrame original. PERO si NO se desean conservar los valores antiguos, se puede establecer la palabra clave 'inplace en True', que por defecto traera una copia de los datos. 'inplace' usualmente esta en False."""

edu.drop('ValueNorm', axis = 1, inplace = True)
edu.head(15)

"""En este caso usamos la funcion .loc para agregar una nueva fila, ya que la funcion append, ya no es usada en las nuevas versiones de pandas. La estructura seria la siguiente, se crea una variable con la que podamos guardar los valores, además, dentro del corchete se colocan las con comillas simples o normales el nombre de las columnas con el valor correspondiente de cada dato. luego en la segunda linea de abajo, le ponemos la variable donde estamos guardando los datos de la tabla, le ponemos el .loc, luego la funcion len la cual nos permite tomar toddos los conjuntos de datos y aplicarlos a la tabla."""

NuvaFila = {'TIME': 2000, 'Value': 5.00, 'GEO': 'a'}
edu.loc[len(edu)] = NuvaFila
edu.tail(15)

"""Elimiaremos la ultima fila agregada usando la funcion 'drop', especificando que es una fila 'axis = 0', y como es la ultima fila podemos usar la funcion 'max'."""

edu.drop(max(edu.index), axis=0, inplace=True)
edu.tail(15)

"""usamos la función dropna con el argumento subset, subset=['Value'] le dice a pandas que solo considere los valores faltantes en la columna 'Value'."""

eduDrop = edu.dropna(subset=["Value"], axis = 0)

eduDrop.head(10)

"""usamos el 'dropna' para eliminar valores nulos, para borrar las filas la cuales tienen valores nulos, tenemos que usar la palabra 'how' en 'any', con esto lo restringimos a un subconjunto el cual lo especificamos con la palabra 'subset'."""

eduDrop = edu.dropna(how = 'any', subset=['Value'])
eduDrop.head(10)

"""Con el metodo 'fillna()' podemos rellenar los valores nulos, eso dandole el valor que queremos que le ponga, en este casi seria '0', dentro de este metodo tiene que ir el nombre de la columna a la cual le queremos poner el valor en vez de los valores nulos."""

eduFilled = edu.fillna(value = {'Value': 0})
eduFilled.head(10)

"""Con la funcion 'sort' podemos organizar los datos de manera que qeramos en caso seria mostrar los primeros 10 datos y ordenarlos de manera acendete."""

edu.sort_values(by = 'Value', ascending = False,
                inplace = True)
edu.head(10)

"""hay que tener en cuenta que 'inplace' significa que se sobrescribira y que no devolvera un nuevo DataFrame. Además al poner el ascending en True, significa que los datos se organizaran de manera decendente, osea de menor a mayor."""

edu.sort_index(axis = 0, ascending = True, inplace = True)
edu.head(9)

"""En este caso agrupamos los datos, en este caso agrupamos todos los paises, sin importar el año y con la funcion 'mean' como metodo de agregación, el resultado son los paises con los valores medios como columna en Value."""

group = edu[['GEO', 'Value']].groupby('GEO').mean()
group.head()

"""Podemos transformar la disposición de los datos, redistribuyendo los indices y las columnas, para esto podemos usar 'pivot_table' con esto podemos especifcar que columnas seran los nuevos indices, los nuevos valores y las nuevas columnas.

Por ejemplo, imaginemos que queremos transformar nuestro DataFrame en una estructura similar a una hoja de cálculo con los nombres de los países como índice, mientras que las columnas serán los años a partir de 2006 y los valores serán la columna Valor anterior. Para ello, primero tenemos que filtrar los datos y luego pivotarlos de esta manera:
"""

filtered_data = edu[edu['TIME'] > 2005]
pivedu = pd.pivot_table(filtered_data, values = 'Value',
                        index = ['GEO'],
                        columns= ['TIME'])
pivedu.head(10)

"""Ahora podemos utilizar el nuevo índice para seleccionar filas específicas por etiqueta, utilizando .loc"""

pivedu.loc[['Spain','Portugal'], [2006,2011]]

"""Para ello, primero eliminamos las entradas de la zona euro y acortamos la entrada del nombre de Alemania, utilizando la función rename y luego eliminamos todas las filas que contengan algún NaN, utilizando la función dropna. Ahora podemos realizar la clasificación utilizando la función rank. Observe que el parámetro ascendente=False hace que el ranking vaya de los valores más altos a los más bajos."""

pivedu = pivedu.drop([
                      'Euro area (15 countries)',
                      'Euro area (15 countries)',
                      'Euro area (17 countries)',
                      'Euro area (18 countries)',
                      'European Union (25 countries)',
                      'European Union (27 countries)',
                      'European Union (28 countries)'
                  ],
                     axis = 0)
pivedu = pivedu.rename(index={'Germany (until 1990 former territory of the FRG)': 'Germany'})
pivedu = pivedu.dropna()
pivedu.rank(ascending=False, method='first').head()

""" A continuación, podemos ordenar los valores resultantes para recuperar los cinco primeros países de los últimos 6 años.

"""

totalSum = pivedu.sum(axis = 1)
totalSum.rank(ascending=False, method='dense').sort_values().head()

"""Por ejemplo, si queremos trazar los valores acumulados de cada país en los últimos 6 años, podemos tomar la Serie obtenida en el ejemplo anterior y trazarla directamente llamando a la función plot como se muestra en la siguiente celda."""

totalSum = pivedu.sum(axis = 1).sort_values(ascending = False)
totalSum.plot(kind = 'bar', style = 'b', alpha = 0.4, title='Total Values for Country')

""" hemos utilizado un gráfico de barras horizontales (kind='barh') apilando todos los años en la misma barra de países. Esto puede hacerse ajustando el parámetro stacked a True. Esto puede hacerse ajustando el parámetro stacked a True. El número de colores por defecto en un gráfico es sólo 5, por lo tanto si tiene más de 5 Series que mostrar, necesita especificar más colores o de lo contrario se volverá a utilizar el mismo conjunto de colores. Podemos establecer un nuevo conjunto de colores utilizando la palabra clave color con una lista de colores. Los colores básicos tienen un código de un solo carácter asignado a cada uno, por ejemplo, "b" es para el azul, "r" para el rojo, "g" para el verde, "y" para el amarillo, "m" para el magenta y "c" para el cian. Si queremos cambiar esto, podemos utilizar la función leyenda del objeto eje (este es el objeto devuelto cuando se llama a la función trazar). Utilizando la palabra clave loc, podemos establecer la posición relativa de la leyenda con respecto al gráfico. Puede ser una combinación de derecha o izquierda y superior, inferior o centro. Con bbox_to_anchor podemos establecer una posición absoluta con respecto al gráfico, lo que nos permite colocar la leyenda fuera del gráfico."""

my_colors = ['b', 'r', 'g', 'y', 'm', 'c']
ax = pivedu.plot(kind = 'barh', stacked = True, color = my_colors)
ax.legend(loc = 'center left', bbox_to_anchor = (1, 0.5))